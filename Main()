#include <TinyGPS++.h> // A library created to decode the NMEA GPS strings (not AirMar Specific), file must be on your computer
#include <wayPointclass.h>
#include "Energia.h" // The basic MSP430 Library, allows the use of basic control terms (ex. HIGH.LOW, ect.)
#include <Servo.h>   // Use for control of the wing sail servo
  
#define PinRC 13
#define PinWing 19
#define PinRudder 9
#define PinRCwing 12
#define PinRCrudder 11
#define PinRudderPos 5
  
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Servo wingServo; //Creates the servo as an object, requires the Servo.h library be included
int wingPos = 0;  //Creates the variable to store the wing servo position
Servo rudder;
int rudderPos = 0;

int WingPWM = 90;
int RudderPWM = 90;
int PWMfactorWing = 0.01;
int PWMfactorRudder = 0.01;
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//RC Globally defined variables

// The values that are read from the input pins
int rcON;
int rcWing;
int rcRudder;

// The values that are mapped to the correct range for output pins
int rcONValue;
int rcWingValue;
int rcRudderValue;
int rcONAvg; //A running average which is then output to the board

//the board internal timmer for time-out move ons
long TimeRC;
long TimeRudder;
long TimeWing;

//Update rates
static const int TimeRateWing = 10;
static const int TimeRateRudder = 10;
static const int TimeRateRC = 100;
static const int rcHertz=100;
///////////////////////////////////////////////////////////////////////////////////////////
TinyGPSPlus gps; //Creates a object with in the TinyGPS library 
TinyGPSCustom windTrueMeasure(gps, "WIMDA", 3); //Custom class that retreives the wind angle (0 to 359.9, in relation to bow)
TinyGPSCustom headingMeasure(gps, "HCHDT", 1); //Custom class that retreives the true heading in degrees (x.x) 
TinyGPSCustom windMeasure(gps, "WIMWV", 1); //Custom class that wind angle in relation to magnetic north 
TinyGPSCustom rollMeasure(gps, "YXXDR", 5); //Custom class for roll angular displacment, Roll to STBD is positive
TinyGPSCustom pitchMeasure(gps, "YXXDR", 1); //Custom class for Pitch angular displacment
TinyGPSCustom magXMeasure(gps, "PAMTO", 1); //Custom class for Pitch angular displacment
TinyGPSCustom magYMeasure(gps, "PAMTO", 2); //Custom class for Pitch angular displacment
//////////////////////////////////////////////////////////////////////////////////////////
// Compass navigation
int targetHeading;              // where we want to go to reach current waypoint
int currentHeading;             // where we are actually facing now
int headingError;               // signed (+/-) difference between targetHeading and currentHeading
#define HEADING_TOLERANCE 5     // tolerance +/- (in degrees) within which we don't attempt to turn to intercept targetHeading

/////////////////////////////////////////////////////////////////////////////////////////////////
const int numWindReadings = 5;
int windRelativeToMark;

int readings[numWindReadings]; // the readings from the wind angle input
int indexWind = 0; // the indexWind of the current reading
int totalWind = 0; // the running totalWind
int averageWindAngle = 0; // the average Wind
int currentWindAngle; //the actual wind 
//////////////////////////////////////////////////////////////////////////////////////////////

int readingsTrue[numWindReadings]; // the readings from the wind angle input
int totalTrueWind = 0; // the running total Wind
int averageTrueWindAngle = 0; // the averageWind
int currentTrueWindAngle; //the actual wind 
////////////////////////////////////////////////////////////////////////////////////////////////
enum sailConditions {up, dwn, bm} ;
sailConditions sailCondition = dwn;

//Steering Options
enum directions {port, stbd, straight} ;
directions turnDirection = straight;


//WayPoint Distances
float currentLat,
      currentLng,
      targetLat,
      targetLng;
int distanceToTarget = 100,            // current distance to target (current waypoint)
    originalDistanceToTarget;    // distance to original waypoing when we started navigating to it   
double courseToWayPoint; 
double courseToWayPointTack;
    
// Waypoints
#define WAYPOINT_DIST_TOLERANE  .0001   // tolerance in meters to waypoint; once within this tolerance, will advance to the next waypoint
#define NUMBER_WAYPOINTS 5          // enter the numebr of way points here (will run from 0 to (n-1))
int waypointNumber = -1;            // current waypoint number; will run from 0 to (NUMBER_WAYPOINTS -1); start at -1 and gets initialized during setup()
waypointClass waypointList[NUMBER_WAYPOINTS] = 
    {waypointClass(40.88503, -73.64429), //Corner of parking lot and top of hill at soccer field
    waypointClass(40.88539, -73.64390), //Corner of backstop next to soccer field
    waypointClass(40.88563, -73.64447), //Middle of soccer field
    waypointClass(40.885310, -73.644939), //South West corner of soccer field
    waypointClass(40.88503, -73.64429) }; //Back to top of soccer field 
    

boolean LEDstate;
////////////////////////////////////////////////////////////////////////////////////////////////////

boolean tack = true; //Only true when we are in the process of tacking, set false once a tack is complete
boolean onPort = true; //Port(true) and Stbd(false)
int timeSinceTack;
int timeOfTack; 
int currentTime;
const int timeToTack = 4;
//////////////////////////////////////////////////////////////////////////////////////////////////////

int roll;
int pitch;
int magX;
int magY;

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void setup()
{
  //Begin Serial Communication and LED outputs (both used for debugging)
  Serial.begin(115200);  // This will pass any information we want to the computer for debugging 
  Serial1.begin(4800);	// opens serial port, sets data rate to 9600 bps, Used for the Airmar 150wx Sensor. 
  
  //LED Use is only for help determining what section of code the program is executing (used in SailCondition())
  pinMode(RED_LED, OUTPUT); // initialize the digital pin as an output.
  pinMode(GREEN_LED, OUTPUT); // initialize the digital pin as an output.
  LEDstate = true; //a flipping counter for the LED pins
  
  //Assign wing and servo control outputs to pin numbers & RC signal as inputs 
  wingServo.attach(PinWing);  // Wing Servo: attaches the servo on pin 19 to the servo object for the wing sail servo
  rudder.attach(PinRudder); //The rudder actuator is controlled via a controller as if it were a servo
  //pinMode(PinRudder, OUTPUT);    // Rudder Motor: attaches the signal for the linear actuator to pin 9 for the rudder control
  pinMode(PinRC, INPUT);     // RC Enabled: input to determin if the a switch on the RC controller is on
  pinMode(PinRCwing, INPUT);     // RC Mode Wing: input for the RC controller of the wing servo
  pinMode(PinRCrudder, INPUT);     // RC Mode Rudder: input for the RC controller to the linear actuator 
  pinMode(PinRudderPos, INPUT);     // Ruder Motor: Read for the rudder position (linear potentiometer) 

  // get initial waypoint; also sets the distanceToTarget and courseToTarget varilables
  nextWaypoint();
  
  //wind angle array initialization
    for (int thisWindReading = 0; thisWindReading < numWindReadings; thisWindReading++)
    readings[thisWindReading] = 0; 
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void loop()
{
    
    getAirmarInfo(); //Retrieves the Latitude, Longitude, and compass heading 
    WindAngleAvg(); //A running average of the wind angle relative to magnetic nonrth and of True Wind to the boats bow
    distanceToWaypoint();
      //Sub-Function: nextWaypoint() only called when distance is within tolerance to waypoint
    SailCondition();  //also calls the coursetoWaypoint functions that sets the targetHeading variable  
        //Sub-Functions: courseToWaypoint1() & upWindLights() || courseToWaypoint2() & beamReachLights() || courseToWaypoint3() & downWindLights()   
    CalcDesiredTurn();
    changeRudderAngle(); //Execute the turn correction (the actual motor control)
    changeWingAngle();
    isRCmode(); //Determins if we are in RC mode, 
      //Sub-Functions: rcMOde()
          //Sub-Functions rcRudderPosition() || rcWingPosition()
    //Add on Functions: smartDelay()
    smartDelay(500);
    Serial.println("Loop");
} //End Loop
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void getAirmarInfo()
{

// Every time anything is updated, print everything.
if (gps.location.isUpdated() || gps.satellites.isUpdated() ||
    headingMeasure.isUpdated() || windMeasure.isUpdated() || 
    rollMeasure.isUpdated() || pitchMeasure.isUpdated() || gps.time.minute() ||
    magXMeasure.isUpdated() || magYMeasure.isUpdated() )
  {
    Serial.print(F("ALT="));   Serial.print(gps.altitude.meters()); 
    Serial.print(F(" windMeasure=")); Serial.print(windTrueMeasure.value()); 
    Serial.print(F(" headingMeasure=")); Serial.print(headingMeasure.value()); 
   // Serial.print(F(" VDOP=")); Serial.print(vdop.value());
    Serial.print(F(" SATS=")); Serial.println(gps.satellites.value());
    currentLat = (gps.location.lat())/100;
    currentLng = (gps.location.lng())/100;
    currentHeading = atoi(headingMeasure.value());
    currentWindAngle = atoi(windMeasure.value());
    currentTrueWindAngle = atoi(windTrueMeasure.value());
    pitch = atoi(pitchMeasure.value());
    roll = atoi(rollMeasure.value());
    currentTime = (gps.time.minute());
    magX = atoi(magXMeasure.value());
    magY = atoi(magYMeasure.value());
 
  }

  while (Serial1.available() > 0)
    gps.encode(Serial1.read());

}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void WindAngleAvg()
{
  
  // subtract the last reading:
  totalWind= totalWind - readings[indexWind]; 
  // read from the sensor: 
  readings[indexWind] = currentWindAngle; //This needs to be made to equal the actual wind value read each time from the serial stream
  // add the reading to the totalWind:
  totalWind= totalWind + readings[indexWind]; 

  // calculate the averageWind:
  averageWindAngle = totalWind / numWindReadings;
  
//-----------TRUE WIND----------------------------------
  // subtract the last reading:
  totalTrueWind = totalTrueWind - readingsTrue[indexWind]; 
  // read from the sensor: 
  readingsTrue[indexWind] = currentTrueWindAngle; //This needs to be made to equal the actual wind value read each time from the serial stream
  // add the reading to the totalWind:
  totalTrueWind = totalTrueWind + readingsTrue[indexWind]; 
  // calculate the averageWind:
  averageTrueWindAngle = totalTrueWind / numWindReadings;
  
//----------Array Placement---------------------------
  // advance to the next position in the array: 
  indexWind = indexWind + 1; 

  // if we're at the end of the array...
  if (indexWind >= numWindReadings) 
    // ...wrap around to the beginning: 
    indexWind = 0; 
//----------------------------------------------------

windRelativeToMark = averageWindAngle - courseToWayPoint;
 if(windRelativeToMark > 180)
    windRelativeToMark = 360 - windRelativeToMark;
    
} //end windAngle() */ 

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// modified from TinyGPS library
int distanceToWaypoint() 
{
  
  float delta = radians(currentLng - targetLng);
  float sdlong = sin(delta);
  float cdlong = cos(delta);
  float lat1 = radians(currentLat);
  float lat2 = radians(targetLat);
  float slat1 = sin(lat1);
  float clat1 = cos(lat1);
  float slat2 = sin(lat2);
  float clat2 = cos(lat2);
  delta = (clat1 * slat2) - (slat1 * clat2 * cdlong); 
  delta = sq(delta); 
  delta += sq(clat2 * sdlong); 
  delta = sqrt(delta); 
  float denom = (slat1 * slat2) + (clat1 * clat2 * cdlong); 
  delta = atan2(delta, denom); 
  distanceToTarget =  delta * 6372795; 
   
  // check to see if we have reached the current waypoint
  if (distanceToTarget <= WAYPOINT_DIST_TOLERANE)
    nextWaypoint();
    
  return distanceToTarget;
}  // distanceToWaypoint()

////////////////////////////////////////////////////////////////////////////////////////////////////////

int SailCondition()
{
    //What sail condition are we in????----------------------------------------------------------------------
   
   if (windRelativeToMark >= 0 && windRelativeToMark < 45){sailCondition = up;}
   else if (windRelativeToMark >= 45 && windRelativeToMark <= 135) {sailCondition = bm;}
   else (windRelativeToMark > 135 && windRelativeToMark <= 180); {sailCondition = dwn;}
    
    switch (sailCondition)
    {
      case up: //upwind, should flash red and green LED
      
      upWindLights();
      courseToWaypoint1();
      
      break;
      
      case bm: //beam reach, should flash red LED
       beamReachLights();
       courseToWaypoint2();
      break;
      
      case dwn: //down wind, should flash green LED
      
      downWindLights();
      courseToWaypoint3();
      
      break;
      
      default: //if nothing else matches do this 
      upWindLights();
      break;
      
    } // End of the Sailing Condition decisions (switch case)
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////
//-----------UP WIND-------------------------------------------
int courseToWaypoint1() //Up Wind
{
  targetHeading = averageWindAngle + 45;
 
} //courseToWaypoint1() Up Wind

//-----------BEAM REACH----------------------------------------- 
// modified from TinyGPS library
int courseToWaypoint2() //beam reach
{

  float dlon = radians(targetLng-currentLng);
  float cLat = radians(currentLat);
  float tLat = radians(targetLat);
  float a1 = sin(dlon) * cos(tLat);
  float a2 = sin(cLat) * cos(tLat) * cos(dlon);
  a2 = cos(cLat) * sin(tLat) - a2;
  a2 = atan2(a1, a2);
  if (a2 < 0.0)
  {
    a2 += TWO_PI; 
  }
  targetHeading = degrees(a2);  
  
  return targetHeading;
}   // courseToWaypoint2() beam reach

//-------------DOWN WIND----------------------------------------
int courseToWaypoint3() //down wind
{
 targetHeading = averageWindAngle + 135; //Set course so thatthe true wind is equal to 135 deg. 
 
 //correct for anglular wrap around
 if(targetHeading > 360)
 targetHeading -= 360;
 else if(targetHeading < 0)
 targetHeading += 360; 
} //courseToWaypoint3() down wind

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CalcDesiredTurn(void)
{
    // calculate where we need to turn to head to destination
    headingError = targetHeading - currentHeading;
    
    // adjust for compass wrap
    if (headingError < -180)      
      headingError += 360;
    if (headingError > 180)
      headingError -= 360;
  
    // calculate which way to turn to intercept the targetHeading
    if (abs(headingError) <= HEADING_TOLERANCE)      // if within tolerance, don't turn
      turnDirection = straight;  
    else if (headingError < 0)
      turnDirection = port;
    else if (headingError > 0)
      turnDirection = stbd;
    else
      turnDirection = straight;
 
}  // calcDesiredTurn()

///////////////////////////////////////////////////////////////////////////////////////////////////////

void changeRudderAngle() //Add additional case statements that increase or decrease proportional to how much turn is needed
{
  if(turnDirection == port) 
  RudderPWM = RudderPWM + headingError*PWMfactorRudder;
  else if(turnDirection == stbd)
  RudderPWM = RudderPWM - headingError*PWMfactorRudder;
  else 
  RudderPWM = RudderPWM;
  
  rudder.write(RudderPWM);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////

void changeWingAngle() //Add additional case statements that increase or decrease proportional to how much turn is needed
{
  //The servo PWM is written directly as its angle between 0 and 180
  if(averageWindAngle <=180){};
    
  WingPWM = WingPWM;
  wingServo.write(WingPWM); 
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////

void nextWaypoint(void)
{
  waypointNumber++;
  targetLat = waypointList[waypointNumber].getLat();
  targetLng = waypointList[waypointNumber].getLong();
  
 // if ((targetLat == 0 && targetLng == 0) || waypointNumber >= NUMBER_WAYPOINTS)    // last waypoint reached? 
  if (waypointNumber >= NUMBER_WAYPOINTS)    // last waypoint reached? 
    {

      Serial.println("End of Way Points Reached");
       
    }
    
   distanceToTarget = originalDistanceToTarget = distanceToWaypoint();
   
}  // nextWaypoint()

//////////////////////////////////////////////////////////////////////////////////////////////////////

// Sailing Condition indicator Lights
void upWindLights()
{
  if(LEDstate == true)
  {
      digitalWrite(RED_LED, HIGH);
      digitalWrite(GREEN_LED, LOW);  // turn the LED on (HIGH is the voltage level)
       Serial.println("up wind flash on"); 
      LEDstate = false;
  }
  else
  {
      digitalWrite(RED_LED, LOW);
      digitalWrite(GREEN_LED, HIGH);  // turn the LED on (HIGH is the voltage level) 
      Serial.println("up wind flash off");
      LEDstate = true;
  }
  
} // END of upWindLights function 
//-----------------------------------------------------------------------------------------------
void beamReachLights()
{
  if(LEDstate == true)
  {
      digitalWrite(RED_LED, HIGH);
      Serial.println("beam wind on");
      LEDstate = false;
  }
  else
  {
      digitalWrite(RED_LED, LOW);
      Serial.println("beam wind low");
      LEDstate = true;
  }
  digitalWrite(GREEN_LED, LOW);
  
} // END of beamReachLights function 
//-----------------------------------------------------------------------------------------------
void downWindLights()
{
  if(LEDstate == true)
  {
      digitalWrite(GREEN_LED, HIGH);
      Serial.println("down wind on");
      LEDstate = false;
  }
  else
  {
      digitalWrite(GREEN_LED, LOW);
      Serial.println("down wind low");
      LEDstate = true;
  }
  digitalWrite(RED_LED, LOW);
} // END of downWindLights function 

////////////////////////////////////////////////////////////////////////////////////////////////////

void isRCmode()
{
    int rcPin = 0;             // varible to intialize the RC enable pin
    rcPin = digitalRead(PinRC);   // Determins whether or not signal is recieved from flipping switch on RC controller
    if(rcPin == HIGH)          // IF there is a RC SIGNAL then do the following....
    {
      rcMode(); // Function to run vessel on RC control-------------------------------------------------------------
      
    } // End RC if statement check
}    
//-----------------------------------------------------------------------------------------------------------------    
void rcMode(){
  int rcOutLow = 0;
  int rcOutHigh = 180;
  int rcInHigh = 2000;
  int rcInLow = 0; 
  
  if(millis()-TimeRC>(1000/rcHertz)){ //if a certain time has past since last rc data, get rc data

    // Read the pulse width of each channel
    rcON = pulseIn(PinRC, HIGH, 25000); // RC Enabled flip switch
    rcWing = pulseIn(PinRCwing, HIGH, 25000); // RC wing control 
    rcRudder = pulseIn(PinRCrudder, HIGH, 25000); // RC rudder control
    
    //Convert the rc signal to something useable on our device
    rcONValue = map(rcON,rcInLow, rcInHigh, rcOutLow, rcOutHigh); 
    rcWingValue = map(rcWing,rcInLow, rcInHigh, rcOutLow, rcOutHigh); 
    rcRudderValue = map(rcRudder,rcInLow, rcInHigh, rcOutLow, rcOutHigh); 
   
    //A rolling average of the RC inputs
    rcONAvg = (rcONAvg + rcONValue)/2;
    WingPWM = (WingPWM + rcWingValue)/2; 
    RudderPWM = (RudderPWM + rcRudderValue)/2; 
    
    rcRudderPosition();
    rcWingPosition();
  
    TimeRC= millis(); //change of time
  }
}

//RC Control of the Sail Servo----------------------------------------------------------------------

void rcRudderPosition()
{
  
     if(millis()-TimeRudder>(1000/TimeRateRudder)){ //if a certain time has past since last printed data, print data
         
        rudder.write(RudderPWM);
        //0 = full speed stbd
        //90 = neutral
        //180 = full speed port
  
        TimeRudder=millis(); //time since last data print is zero
     }
}


//Control of the Servo------------------------------------------------------------------------------


void rcWingPosition(){
  
     if(millis()-TimeWing>(1000/TimeRateWing)){ //if a certain time has past since last printed data, print data
         
        wingServo.write(WingPWM);
  
        TimeWing=millis(); //time since last data print is zero
     }
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// This custom version of delay() ensures that the gps object
// is being "fed".
static void smartDelay(unsigned long ms)
{
  unsigned long start = millis();
  do 
  {
    while (Serial1.available())
      gps.encode(Serial1.read());
  } while (millis() - start < ms);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void courseToPoint()
{
   courseToWayPoint =
    TinyGPSPlus::courseTo(
      currentLat,
      currentLng,
      targetLat, 
      targetLng);
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////
void courseOnTack()
{
   
 courseToWayPointTack = targetHeading + (2*averageTrueWindAngle);
 if(courseToWayPointTack > 360)
 courseToWayPointTack -= 360;
 else if(courseToWayPointTack < 0)
 courseToWayPointTack += 360; 
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////
void ShouldWeTack()
{ 
      //roll over the time if the end of hour is reached. Time counts minutes, only to 60.
      if(currentTime < timeOfTack)
      {currentTime += 60;}
       
      timeSinceTack = currentTime - timeOfTack;
      
      //If enough time has passed since last tack, then check the conditions to tack (time is #defined at top)      
      if(timeToTack < timeSinceTack)
      {
                  if(courseToWayPoint - courseToWayPointTack < courseToWayPoint - targetHeading) //If True we need to tack
                  {
                  tack = true;
                  timeOfTack = currentTime;
                        if(onPort) //If Port is true, true wind is to port side
                        {
                          targetHeading = targetHeading + (2*averageTrueWindAngle); 
                        }                      
                  } //end if(courseToWayPoint)
      } //end if(timeToTack)
  
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////
/* tilt compensated magnetic sensor measurements
  float magxcomp = Magx*cos(Pitch)+Magz*sin(Pitch);
  float magycomp = Magx*sin(Roll)*sin(Pitch)+Magy*cos(Roll)-Magz*sin(Roll)*cos(Pitch);

  // arctangent of y/x converted to degrees
  Heading = 180*atan2(magycomp,magxcomp)/PI;
  */
  
